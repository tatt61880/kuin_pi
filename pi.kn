{
    pi.kn (for Kuin 0.023):
        Last Modified: 2013/03/24 17:46:46.
        Created by @tatt61880

    下記のサイトを参考に作成しました。
        http://mail2.nara-edu.ac.jp/~asait/c_program/sample0/pi.htm
}
const M:int :: 2502
const N:int :: 2078

func Main()
    var x:[]byte32 :: @new [pi@N]byte32
    var y:[]byte32 :: @new [pi@N]byte32

    do pi@ATAN(x, 5)
    do pi@Mul(x, 4$byte32)

    do pi@ATAN(y, 239)

    do pi@Sub(x, y)
    do pi@Mul(x, 4$byte32)

    do pi@Display(x)
end func

func ATAN(x:[]byte32, m:int)
    var e:int
    var m2:byte32
    var y:[]byte32 :: @new [pi@N]byte32
    var z:[]byte32 :: @new [pi@N]byte32
    for i(0, pi@N-1)
        do x[i] :: 0$byte32
        do y[i] :: 0$byte32
    end for
    do y[0] :: 1$byte32

    do pi@Div(y, m$byte32)
    do pi@Dup(y, x)
    do m2 :: (m*m)$byte32
    var i:int :: 1
    while (e = -1, skip)
        do pi@Div(y, m2)
        do pi@Dup(y, z)
        do pi@Div(z, (2*i+1)$byte32)
        if ( (i % 2) = 0 ) {if( (i & 1) == 0 )  ビット積未実装}
            do pi@Add(x, z)
        else
            do pi@Sub(x, z)
        end if
        do i :+ 1
        do e :: pi@if_zero(z)
    end while
end func

func Add(a:[]byte32, b:[]byte32)
    var j:int
    var x:byte32
    for i(0, pi@N-1)
        do x :: a[i] + b[i]
        if(x <= #FFFF $byte32)
            do a[i] :: x
        else
            do a[i] :: x % #10000$byte32 {x & 0xffff; ビット積未実装}
            do j :: i-1
            while(a[j] = #FFFF$byte32)
                do a[j] :: 0$byte32
                do j :- 1
            end while
            do a[j] :+ 1$byte32
        end if
    end for
end func

func Sub(a:[]byte32, b:[]byte32)
    var j:int
    for i(0, pi@N-1)
        if (a[i] >= b[i])
            do a[i] :: a[i] - b[i]
        else
            do a[i] :: #10000$byte32 + a[i] - b[i]
            do j :: i-1
            while(a[j] = 0$byte32)
                do a[j] :: #FFFF$byte32
                do j :- 1
            end while
            do a[j] :- 1$byte32
        end if
    end for
end func

func Div(a:[]byte32, d:byte32)
    var x:byte32
    var q:byte32
    var res:byte32
    do res :: 0$byte32
    for i(0, pi@N-1)
        do res :* (2^16)$byte32 {res = res << 16; シフト演算未実装}
        do x :: a[i] + res
        do q :: x/d
        do a[i] :: q
        do res :: x - q*d
    end for
end func

func Mul(a:[]byte32, d:byte32)
    var i:int
    var x:byte32
    var q:byte32
    do q :: 0$byte32
    for i(pi@N-1, 0, -1)
        do x :: a[i]*d + q
        do a[i] :: x % #10000$byte32 {x & 0xffff; ビット積未実装}
        do q :: x / (2^16)$byte32 {q = x >> 16; シフト演算未実装}
    end for
end func

func Dup(a:[]byte32, b:[]byte32)
    for i(0, pi@N-1)
        do b[i] :: a[i]
    end for
end func

func if_zero(a:[]byte32) :int
    var j:int
    do j :: 0
    for i(0, pi@N-1)
        if (a[i] <> 0$byte32)
            do j :: -1
            break i
        end if
    end for
    return j
end func

func Display(a:[]byte32)
    var j:int
    var w:[]byte32 :: @new [pi@M]byte32
    do pi@to_decimal(a, w)
    var str:[]char :: ""
    do str :~ (w[0]$int).ToStrF("4.1d") ~ "." {printf("%4.1u.",w[0])}
    for i(1, pi@M-1)
        do str :~ (w[i]$int).ToStrF("4.4d") ~ " " {printf("%4.4u ", w[i])}
        do j :: i%12
        if(j=0)
            do str :~ "\n     " {printf("\n     ")}
        end if
    end for
    do str :~ "\n" {printf("\n")}
    do Kuin@Dbg(str)
end func

func to_decimal(a:[]byte32, w:[]byte32)
    var b:[]byte32 :: @new [pi@N]byte32
    for i(0, pi@N-1)
        do b[i] :: a[i]
    end for
    do w[0] :: b[0]
    do b[0] :: 0$byte32
    for i(1, pi@M-1)
        do pi@Mul(b, 10000$byte32)
        do w[i] :: b[0]
        do b[0] :: 0$byte32
    end for
end func

